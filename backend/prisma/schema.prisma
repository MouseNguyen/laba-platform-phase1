generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ======================================================================
// MIGRATION CHECKLIST - MUST COMPLETE BEFORE RUNNING:
// ======================================================================
// 1. ✅ Backup production DB: pg_dump laba_platform > backup_$(date +%Y%m%d).sql
// 2. ✅ Check DB connection: npx prisma db pull
// 3. ✅ Verify no pending migrations: npx prisma migrate status
// 4. ✅ Run in dev first: npx prisma migrate dev --name add-posts-table
// 5. ✅ Test seed: npm run db:seed
// 6. ✅ If all good, deploy to staging: npx prisma migrate deploy
// 7. ✅ Finally deploy to production: npx prisma migrate deploy
// ======================================================================

model User {
  id                    Int       @id @default(autoincrement())
  email                 String    @unique
  password_hash         String
  full_name             String?
  token_version         Int       @default(0)
  email_verified_at     DateTime?
  failed_login_attempts Int       @default(0)
  lock_until            DateTime?
  last_failed_attempt   DateTime?

  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  deleted_at DateTime?

  tokens        UserToken[]
  user_roles    UserRole[]
  user_branches UserBranch[]
  posts         Post[]

  @@map("users")
}

model UserToken {
  id                 Int    @id @default(autoincrement())
  user_id            Int
  refresh_token_hash String @unique
  device_hash        String
  device_info        Json

  expires_at DateTime
  created_at DateTime  @default(now())
  revoked_at DateTime?

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([refresh_token_hash])
  @@map("user_tokens")
}

model Role {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String?

  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  deleted_at DateTime?

  user_roles       UserRole[]
  role_permissions RolePermission[]

  @@map("roles")
}

model Permission {
  id          Int     @id @default(autoincrement())
  slug        String  @unique
  description String?

  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
  deleted_at DateTime?

  role_permissions RolePermission[]

  @@map("permissions")
}

model UserRole {
  user_id Int
  role_id Int

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  role Role @relation(fields: [role_id], references: [id], onDelete: Cascade)

  @@id([user_id, role_id])
  @@map("user_roles")
}

model RolePermission {
  role_id       Int
  permission_id Int

  role       Role       @relation(fields: [role_id], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permission_id], references: [id], onDelete: Cascade)

  @@id([role_id, permission_id])
  @@map("role_permissions")
}

// Branch Model - Multi-tenant support for Laba Platform
// Each branch can be FARM, HOMESTAY, CAFE, or SHOP
// Soft delete enabled for data retention
model Branch {
  id         Int       @id @default(autoincrement())
  code       String    @unique @db.VarChar(50) // Unique identifier for URLs/configs
  name       String    @db.VarChar(255) // Display name
  type       String    @db.VarChar(20) // FARM, HOMESTAY, CAFE, SHOP
  address    String?   @db.VarChar(500) // Full address
  phone      String?   @db.VarChar(30) // Contact phone with country code
  settings   Json?     @db.JsonB // Branch-specific configuration (timezone, hours, etc.)
  isActive   Boolean   @default(true) @map("is_active") // Enable/disable branch

  created_at DateTime  @default(now()) @db.Timestamptz()
  updated_at DateTime  @updatedAt @db.Timestamptz()
  deleted_at DateTime? @db.Timestamptz() // Soft delete

  // Relations
  user_branches UserBranch[]

  // Performance indexes
  @@index([type, isActive]) // Common query: filter by type and active status
  @@index([code]) // Already unique, but explicit for clarity
  @@index([deleted_at]) // Soft delete queries
  @@map("branches")
}

model UserBranch {
  user_id   Int
  branch_id Int

  user   User   @relation(fields: [user_id], references: [id], onDelete: Cascade)
  branch Branch @relation(fields: [branch_id], references: [id], onDelete: Cascade)

  @@id([user_id, branch_id])
  @@map("user_branches")
}

enum LandingStatus {
  draft
  published
  archived
}

enum StoryLinkTarget {
  SELF
  BLANK
}

model LandingContent {
  id                String          @id @default(uuid())
  key               String
  locale            String
  status            LandingStatus
  title             String
  subtitle          String?
  short_story       String
  image_url         String?
  image_mobile_url  String?
  image_alt         String?
  story_link        String?
  story_link_target StoryLinkTarget @default(SELF)
  sort_order        Int
  is_active         Boolean         @default(true)
  created_at        DateTime        @default(now())
  updated_at        DateTime        @updatedAt
  updated_by        Int? // tạm thời Int? để có thể tham chiếu User.id sau này nếu cần

  @@unique([key, locale])
  @@map("landing_contents")
}

model Post {
  id            Int       @id @default(autoincrement())
  type          String    @db.VarChar(20) // Constraint: PAGE, BLOG, NEWS only
  slug          String    @unique @db.VarChar(255) // SEO-friendly, max 255 chars
  title         String    @db.VarChar(500) // Max 500 chars, đủ dài cho title
  excerpt       String?   @db.Text // Có thể dài, dùng Text thay vì VarChar
  content       Json      // Rich text JSON - validated ở application layer
  thumbnailUrl  String?   @db.VarChar(1000) @map("thumbnail_url") // URL có thể rất dài
  authorId      Int?      @map("author_id")
  isPublished   Boolean   @default(false) @map("is_published")
  publishedAt   DateTime? @map("published_at") @db.Timestamptz() // Timezone-aware
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt     DateTime  @updatedAt @map("updated_at") @db.Timestamptz()
  deletedAt     DateTime? @map("deleted_at") @db.Timestamptz() // Soft delete

  // Relations
  author        User?     @relation(fields: [authorId], references: [id], onDelete: SetNull)
  
  // Indexes for performance
  @@index([type, isPublished]) // Query phổ biến: filter by type & published status
  @@index([authorId]) // Query by author
  @@index([slug]) // Already unique, but explicit index helps clarity
  @@index([deletedAt]) // Soft delete queries
  @@map("posts")
}

// ROLLBACK INSTRUCTIONS (nếu migration fail):
// Option 1: npx prisma migrate resolve --rolled-back "add-posts-table"
// Option 2: Restore DB: psql laba_platform < backup_YYYYMMDD.sql

// GIT WORKFLOW:
// 1. Create branch: git checkout -b feature/2.1-add-post-model
// 2. Stage schema: git add prisma/schema.prisma
// 3. Stage seed: git add prisma/seed.ts
// 4. Commit: git commit -m "feat(db): add Post model and seed data for CMS"
// 5. Push: git push origin feature/2.1-add-post-model
// 6. Create PR with title: "Task 2.1: Add Post Model to Prisma Schema"
